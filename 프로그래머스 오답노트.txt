*****************************************프로그래머스 정렬 k번째수**********************************
정답은 맞았는데 효율성 하타치인 이유
1. 정렬할 때 sort보다 set에 넣는게 더 빠를거라고 생각해서 set에 넣은 개짓이 문제였음
2. 애초에 vector를 잘라서 어디 넣고 이런짓이아니라 그냥 iter로 충분히 할 수 있는 거였음
*************************************정답****************************************************
vector<int> solution(vector<int> array, vector<vector<int>> commands) {
    vector<int> answer;
    vector<int> temp;

    for (int i = 0; i < commands.size(); i++) {
        temp = array;
        sort(temp.begin() + commands[i][0] - 1, temp.begin() + commands[i][1]);
        answer.push_back(temp[commands[i][0] + commands[i][2] - 2]);
    }

    return answer;
}
*******************************************************************************************
*****************************************프로그래머스 스택
기술**********************************
맞긴했는데 코드도 길고 드러운 이유
그냥 ㅈ밥이라 그런거같기도함
1. 문제에 접근하는 방식이 너무 평범했음 효율적인 프로그래밍도 중요하지만
문제에 접근 하는 방법도 중요한듯 정답보면 진짜 간단하게도 끝낼 수 있는 코드
*************************************정답****************************************************
vector<int> solution(vector<int> progresses, vector<int> speeds) {
    vector<int> answer;

    int day;
    int max_day = 0;
    for (int i = 0; i < progresses.size(); ++i)
    {
        day = (99 - progresses[i]) / speeds[i] + 1;

        if (answer.empty() || max_day < day)
            answer.push_back(1);
        else
            ++answer.back();

        if (max_day < day)
            max_day = day;
    }

    return answer;
}
*******************************************************************************************
*******************************************************************************************
*****************************************프로그래머스 완전탐색
기술**********************************
고냥 포기해버린이유
1. 문제에 대해 이해를 못함
2. 패턴을 저장해서 사용할 생각을 못함

-- 사실상 패턴을 이용하는 방법을 알았다면 ㅈ밥문제
*************************************정답****************************************************
vector<int> solution(vector<int> answers) {
    vector<int> answer;
    int score[3] = { 0, };
    int P1[5] = { 1,2,3,4,5 };
    int P2[8] = { 2, 1, 2, 3, 2, 4, 2, 5 };
    int P3[10] = { 3, 3, 1, 1, 2, 2, 4, 4, 5, 5 };
    for (int i = 0; i < answers.size()+1; ++i)
    {
        if (answers[i] == P1[(i % 5)])score[0]++;
        if (answers[i] == P2[(i % 8)])score[1]++;
        if (answers[i] == P3[(i % 10)])score[2]++;
    }
    int max_score = max(max(score[0], score[1]), score[2]);
    for (int i = 0; i < 3; i++)
    {
        if (max_score == score[i])answer.emplace_back(i+1);
    }
    return answer;
}
*******************************************************************************************